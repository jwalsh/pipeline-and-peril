#+TITLE: Pipeline & Peril - Project Setup
#+PROPERTY: header-args :mkdirp yes

* Project Overview

This file generates the core documentation and design files for Pipeline & Peril, a board game that uses RPG dice mechanics to simulate distributed systems concepts.

* Core Files Generation

** README.md
:PROPERTIES:
:header-args: :tangle README.md
:END:

#+begin_src markdown
# Pipeline & Peril

A board game that teaches distributed systems concepts through RPG dice mechanics.

## Overview

Players build and maintain a distributed system while fighting entropy ("The Static"). 
Uses polyhedral dice to represent computational concepts:
- d20: Action resolution
- d12: Latency  
- d10: Load/Traffic
- d8: Chaos events
- d6: Resource allocation
- d4: Bug severity

## Quick Start

1. 2-4 players
2. 45-90 minutes
3. Ages 14+

## Components

See `docs/components.md` for detailed component list.

## Rules

See `docs/game-rules.md` for complete rules.

## Design

See `docs/architecture.mmd` for system design diagrams.
#+end_src

** Game Rules
:PROPERTIES:
:header-args: :tangle docs/game-rules.md
:END:

#+begin_src markdown
# Pipeline & Peril - Game Rules

## Objective

Build a resilient distributed system that can handle incoming traffic while defending against The Static's chaos.

## Setup

1. Place the game board in the center
2. Each player takes a character board (Developer, Architect, Data Engineer, or DevOps)
3. Create dice pools:
   - Resource pool: 10d6 per player
   - Chaos pool: 5d8
   - Traffic pool: 10d10
4. Shuffle event cards

## Turn Structure

### Phase 1: Traffic Generation
- Roll 2d10 to determine incoming requests
- Distribute load tokens across services

### Phase 2: Player Actions (3 actions each)
- **Build**: Add a new service tile (cost: 2 actions)
- **Connect**: Create network paths between services (cost: 1 action)
- **Allocate**: Assign d6 resource dice to services (cost: 1 action)
- **Debug**: Remove bugs from services (roll d20 vs bug's d4 severity)
- **Scale**: Add capacity to existing service (cost: varies)

### Phase 3: Resolution
- Each service must roll d20 ≥ (load - allocated resources) or fail
- Failed services cascade failures to dependencies
- Roll d12 for each network hop to determine latency

### Phase 4: Chaos
- Roll d8 on chaos table
- Apply effects (network partitions, CPU spikes, disk failures, etc.)
- Spawn bugs on affected services

## Winning Conditions

**Cooperative**: Survive 10 rounds with system uptime >80%
**Competitive**: Score points for handled requests minus penalties for failures

## Character Abilities

**Developer**: Reroll failed service checks once per turn
**Architect**: Create redundant paths for free
**Data Engineer**: Reduce latency by one step  
**DevOps**: Ignore one chaos event per round
#+end_src

** Components List
:PROPERTIES:
:header-args: :tangle docs/components.md
:END:

#+begin_src markdown
# Components

## Dice
- 4× d20 (action resolution)
- 4× d12 (latency dice)
- 10× d10 (traffic/load dice)
- 5× d8 (chaos dice)
- 20× d6 (resource dice)
- 10× d4 (bug severity dice)

## Tokens
- 50× Load tokens (incoming requests)
- 30× Bug tokens
- 20× Failure tokens
- 40× Resource cubes

## Cards
- 40× Event cards
- 20× Chaos cards
- 4× Character cards
- 4× Reference cards

## Boards & Tiles
- 1× Main game board (connection grid)
- 4× Character boards
- 30× Service tiles
  - 10× Compute services
  - 8× Database services  
  - 6× Cache services
  - 6× Queue services
- 40× Network path connectors

## Tracking
- 4× Uptime trackers
- 1× Round tracker
- 1× Chaos level tracker
#+end_src

** System Architecture Diagram
:PROPERTIES:
:header-args: :tangle docs/architecture.mmd
:END:

#+begin_src mermaid
graph TD
    %% Player Turn Flow
    Start([Start Turn]) --> Traffic[Roll 2d10 for Traffic]
    Traffic --> Distribute[Distribute Load Tokens]
    Distribute --> Actions[Player Actions x3]
    
    Actions --> Build[Build Service]
    Actions --> Connect[Connect Services]
    Actions --> Allocate[Allocate Resources]
    Actions --> Debug[Debug Services]
    Actions --> Scale[Scale Service]
    
    Build --> Resolution
    Connect --> Resolution
    Allocate --> Resolution
    Debug --> Resolution
    Scale --> Resolution
    
    Resolution[Resolution Phase] --> ServiceCheck{Service Check}
    ServiceCheck -->|Pass| Success[Handle Load]
    ServiceCheck -->|Fail| Cascade[Cascade Failure]
    
    Success --> Latency[Roll d12 for Latency]
    Cascade --> Latency
    
    Latency --> Chaos[Chaos Phase]
    Chaos --> ChaosRoll[Roll d8]
    ChaosRoll --> ChaosEffect[Apply Effect]
    
    ChaosEffect --> EndTurn{End Turn}
    EndTurn -->|More Rounds| Start
    EndTurn -->|Game End| Victory{Check Victory}
    
    %% Service States
    subgraph Service States
        Healthy[Healthy Service]
        Degraded[Degraded Service]
        Failed[Failed Service]
        
        Healthy -->|Bug| Degraded
        Degraded -->|Debug| Healthy
        Degraded -->|Overload| Failed
        Failed -->|Repair| Degraded
    end

    style Start fill:#90EE90
    style Victory fill:#FFD700
    style Failed fill:#FF6B6B
    style Chaos fill:#FF8C00
#+end_src

** Game Flow State Machine
:PROPERTIES:
:header-args: :tangle docs/game-flow.mmd
:END:

#+begin_src mermaid
stateDiagram-v2
    [*] --> Setup
    Setup --> RoundStart
    
    RoundStart --> TrafficPhase
    TrafficPhase --> PlayerTurn
    
    PlayerTurn --> ActionSelection
    ActionSelection --> ActionResolution
    ActionResolution --> ActionSelection: More Actions
    ActionResolution --> NextPlayer: No Actions
    
    NextPlayer --> PlayerTurn: More Players
    NextPlayer --> ResolutionPhase: All Players Done
    
    ResolutionPhase --> ServiceChecks
    ServiceChecks --> CascadeFailures
    CascadeFailures --> LatencyCalc
    
    LatencyCalc --> ChaosPhase
    ChaosPhase --> ChaosResolution
    
    ChaosResolution --> RoundEnd
    RoundEnd --> RoundStart: More Rounds
    RoundEnd --> GameEnd: Final Round
    
    GameEnd --> CalculateScore
    CalculateScore --> [*]
    
    note right of ActionSelection
        Build, Connect, Allocate,
        Debug, or Scale
    end note
    
    note right of ChaosPhase
        Roll d8, apply
        system-wide effects
    end note
#+end_src

** Project TODO
:PROPERTIES:
:header-args: :tangle TODO.org
:END:

#+begin_src text
* Pipeline & Peril Development

** DONE Initial Design
- [X] Create dice-to-concept mappings
- [X] Define core mechanics
- [X] Write basic rules

** TODO Prototyping [0/4]
- [ ] Create print-and-play service tiles
- [ ] Design character boards
- [ ] Create reference cards
- [ ] Build chaos/event card deck

** TODO Playtesting [0/3]
- [ ] Solo playtest basic mechanics
- [ ] 2-player balance testing
- [ ] 4-player full game test

** TODO Refinement [0/4]
- [ ] Simplify cascade failure rules
- [ ] Balance chaos frequency
- [ ] Tune resource economy
- [ ] Add advanced variant rules

** TODO Production [0/3]
- [ ] Professional artwork
- [ ] Component sourcing
- [ ] Rulebook layout

** Ideas
*** Alternative Themes
- Space stations instead of servers
- Fantasy magical networks
- Biological systems (neural networks)

*** Expansion Concepts
- Security attacks (new die type: d10 threat level)
- Cloud provider events  
- Microservices complexity cards
- AI/ML workload tiles
#+end_src

** Development Script
:PROPERTIES:
:header-args: :tangle scripts/setup.sh :shebang #!/bin/bash
:END:

#+begin_src bash
# Create project structure
mkdir -p docs
mkdir -p assets/tiles
mkdir -p assets/cards
mkdir -p playtesting

# Create placeholder files
touch playtesting/session-notes.md
touch assets/tiles/service-tiles.svg
touch assets/cards/event-cards.svg

echo "Pipeline & Peril project structure created!"
echo "Run 'org-babel-tangle' in Emacs to generate all files."
#+end_src

* Quick Start

To generate all project files:
1. Open this file in Emacs
2. Run ~C-c C-v t~ (org-babel-tangle)
3. Run ~chmod +x scripts/setup.sh && ./scripts/setup.sh~ to create directories

All documentation will be generated in their respective locations.
